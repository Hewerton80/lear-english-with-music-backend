# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

input ArrayIds {
  values: [String!]!
}

type Author {
  _count: AuthorCount
  createdAt: DateTime!
  id: String!
  name: String!
  slug: String!
}

type AuthorCount {
  songs(where: SongAuthorWhereInput): Int!
}

input AuthorCreateInput {
  createdAt: DateTime
  id: String
  name: String!
  songs: SongAuthorCreateNestedManyWithoutAuthorInput
}

input AuthorOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  slug: SortOrder
  songs: SongAuthorOrderByRelationAggregateInput
}

input AuthorRelationFilter {
  is: AuthorWhereInput
  isNot: AuthorWhereInput
}

input AuthorUpdateInput {
  createdAt: DateTime
  id: String
  name: String
  songs: SongAuthorUpdateManyWithoutAuthorNestedInput
}

input AuthorWhereInput {
  AND: [AuthorWhereInput!]
  NOT: [AuthorWhereInput!]
  OR: [AuthorWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  name: StringFilter
  slug: StringFilter
  songs: SongAuthorListRelationFilter
}

input AuthorWhereUniqueInput {
  id: String
  name: String
  slug: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

type Mutation {
  createAuthor(data: AuthorCreateInput!): Author!
  createSong(authorIds: ArrayIds!, data: SongCreateWithoutAuthorsInput!): Song!
  updateAuthor(data: AuthorUpdateInput!, where: AuthorWhereUniqueInput!): Author!
  updateSong(authorIds: ArrayIds!, data: SongUpdateWithoutAuthorsInput!, where: SongWhereUniqueInput!): Song!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum NullsOrder {
  first
  last
}

input PaginationInput {
  currentPage: Float = 1
  perPage: Float = 25
}

type PaginedAuthor {
  currentPage: Float!
  docs: [Author!]!
  lastPage: Float!
  next: Float
  perPage: Float!
  prev: Float
  total: Float!
}

type PaginedSong {
  currentPage: Float!
  docs: [Song!]!
  lastPage: Float!
  next: Float
  perPage: Float!
  prev: Float
  total: Float!
}

type Query {
  author(where: AuthorWhereUniqueInput!): Author!
  authors(input: PaginationInput!, orderBy: AuthorOrderByWithRelationInput, where: AuthorWhereInput): PaginedAuthor!
  song(where: SongWhereUniqueInput!): Song!
  songs(orderBy: SongOrderByWithRelationInput, paginationInput: PaginationInput!, where: SongWhereInput): PaginedSong!
}

type Song {
  _count: SongCount
  authors: [Author!]!
  createdAt: DateTime!
  id: String!
  lyric: String
  slug: String!
  title: String!
  url: String!
}

input SongAuthorCreateManyAuthorInput {
  createdAt: DateTime
  songId: String!
}

input SongAuthorCreateManyAuthorInputEnvelope {
  data: [SongAuthorCreateManyAuthorInput!]!
  skipDuplicates: Boolean
}

input SongAuthorCreateNestedManyWithoutAuthorInput {
  connect: [SongAuthorWhereUniqueInput!]
  connectOrCreate: [SongAuthorCreateOrConnectWithoutAuthorInput!]
  create: [SongAuthorCreateWithoutAuthorInput!]
  createMany: SongAuthorCreateManyAuthorInputEnvelope
}

input SongAuthorCreateOrConnectWithoutAuthorInput {
  create: SongAuthorCreateWithoutAuthorInput!
  where: SongAuthorWhereUniqueInput!
}

input SongAuthorCreateWithoutAuthorInput {
  createdAt: DateTime
  song: SongCreateNestedOneWithoutAuthorsInput!
}

input SongAuthorListRelationFilter {
  every: SongAuthorWhereInput
  none: SongAuthorWhereInput
  some: SongAuthorWhereInput
}

input SongAuthorOrderByRelationAggregateInput {
  _count: SortOrder
}

input SongAuthorScalarWhereInput {
  AND: [SongAuthorScalarWhereInput!]
  NOT: [SongAuthorScalarWhereInput!]
  OR: [SongAuthorScalarWhereInput!]
  authorId: StringFilter
  createdAt: DateTimeFilter
  songId: StringFilter
}

input SongAuthorSongIdAuthorIdCompoundUniqueInput {
  authorId: String!
  songId: String!
}

input SongAuthorUpdateManyMutationInput {
  createdAt: DateTime
}

input SongAuthorUpdateManyWithWhereWithoutAuthorInput {
  data: SongAuthorUpdateManyMutationInput!
  where: SongAuthorScalarWhereInput!
}

input SongAuthorUpdateManyWithoutAuthorNestedInput {
  connect: [SongAuthorWhereUniqueInput!]
  connectOrCreate: [SongAuthorCreateOrConnectWithoutAuthorInput!]
  create: [SongAuthorCreateWithoutAuthorInput!]
  createMany: SongAuthorCreateManyAuthorInputEnvelope
  delete: [SongAuthorWhereUniqueInput!]
  deleteMany: [SongAuthorScalarWhereInput!]
  disconnect: [SongAuthorWhereUniqueInput!]
  set: [SongAuthorWhereUniqueInput!]
  update: [SongAuthorUpdateWithWhereUniqueWithoutAuthorInput!]
  updateMany: [SongAuthorUpdateManyWithWhereWithoutAuthorInput!]
  upsert: [SongAuthorUpsertWithWhereUniqueWithoutAuthorInput!]
}

input SongAuthorUpdateWithWhereUniqueWithoutAuthorInput {
  data: SongAuthorUpdateWithoutAuthorInput!
  where: SongAuthorWhereUniqueInput!
}

input SongAuthorUpdateWithoutAuthorInput {
  createdAt: DateTime
  song: SongUpdateOneRequiredWithoutAuthorsNestedInput
}

input SongAuthorUpsertWithWhereUniqueWithoutAuthorInput {
  create: SongAuthorCreateWithoutAuthorInput!
  update: SongAuthorUpdateWithoutAuthorInput!
  where: SongAuthorWhereUniqueInput!
}

input SongAuthorWhereInput {
  AND: [SongAuthorWhereInput!]
  NOT: [SongAuthorWhereInput!]
  OR: [SongAuthorWhereInput!]
  author: AuthorRelationFilter
  authorId: StringFilter
  createdAt: DateTimeFilter
  song: SongRelationFilter
  songId: StringFilter
}

input SongAuthorWhereUniqueInput {
  songId_authorId: SongAuthorSongIdAuthorIdCompoundUniqueInput
}

type SongCount {
  authors(where: SongAuthorWhereInput): Int!
}

input SongCreateNestedOneWithoutAuthorsInput {
  connect: SongWhereUniqueInput
  connectOrCreate: SongCreateOrConnectWithoutAuthorsInput
  create: SongCreateWithoutAuthorsInput
}

input SongCreateOrConnectWithoutAuthorsInput {
  create: SongCreateWithoutAuthorsInput!
  where: SongWhereUniqueInput!
}

input SongCreateWithoutAuthorsInput {
  createdAt: DateTime
  id: String
  lyric: String
  title: String!
  url: String!
}

input SongOrderByWithRelationInput {
  authors: SongAuthorOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  lyric: SortOrderInput
  slug: SortOrder
  title: SortOrder
  url: SortOrder
}

input SongRelationFilter {
  is: SongWhereInput
  isNot: SongWhereInput
}

input SongUpdateOneRequiredWithoutAuthorsNestedInput {
  connect: SongWhereUniqueInput
  connectOrCreate: SongCreateOrConnectWithoutAuthorsInput
  create: SongCreateWithoutAuthorsInput
  update: SongUpdateWithoutAuthorsInput
  upsert: SongUpsertWithoutAuthorsInput
}

input SongUpdateWithoutAuthorsInput {
  createdAt: DateTime
  id: String
  lyric: String
  title: String
  url: String
}

input SongUpsertWithoutAuthorsInput {
  create: SongCreateWithoutAuthorsInput!
  update: SongUpdateWithoutAuthorsInput!
}

input SongWhereInput {
  AND: [SongWhereInput!]
  NOT: [SongWhereInput!]
  OR: [SongWhereInput!]
  authors: SongAuthorListRelationFilter
  createdAt: DateTimeFilter
  id: StringFilter
  lyric: StringNullableFilter
  slug: StringFilter
  title: StringFilter
  url: StringFilter
}

input SongWhereUniqueInput {
  id: String
  slug: String
  title: String
}

enum SortOrder {
  asc
  desc
}

input SortOrderInput {
  nulls: NullsOrder
  sort: SortOrder!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}